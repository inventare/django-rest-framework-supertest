{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":""},{"location":"adr/0000-faker-shortcuts/","title":"ADR 0001: Faker Shortcuts","text":"<p>October 2023 . Eduardo Oliveira</p>"},{"location":"adr/0000-faker-shortcuts/#context","title":"Context","text":"<p>When we introduced the faker inside this project, we decided to use only one <code>faker.Faker</code> instance for all model generations. The reason for this is to grant the <code>faker.unique</code> generated values are really unique for various models context with the possibility to clear the already seen values.</p> <p>To use only one <code>faker.Fake</code> instance we decided to parse this as the first argument of the functions to generate field values. To made it more easy to write generator for model fields, we need to write shortcuts for the faker.</p>"},{"location":"adr/0000-faker-shortcuts/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>Easy to set the methods in the <code>@faker_fields</code> decorator.</li> <li>The shortcuts can receive arguments to configure the faker methods.</li> <li>Must include the most part of standard providers of the faker.</li> <li>The shortcuts should be used to directly set the value to an field.</li> </ul>"},{"location":"adr/0000-faker-shortcuts/#decision","title":"Decision","text":"<p>We decided to write shortcuts (this name is an inspiration from the original <code>django.shortcuts</code> package) with the format bellow, with the optional named <code>**kwargs</code>:</p> <p><pre><code>def country_code(fake, representation='alpha-2'):\n    \"\"\"Generate a country code\"\"\"\n    return fake.country_code(representation=representation)\n</code></pre> To use the shortcuts is very easy, using the <code>@faker_fields</code> decorator:</p> <pre><code>from django.db import models\nfrom rest_framework_supertest import shortcuts\nfrom rest_framework_supertest.models.decorators import faker_fields\n\n@faker_fields(\n    title=shortcuts.name,\n    mime=(shortcuts.mime_type, { 'category': 'audio' })\n)\nclass Book(models.Model):\n    title = models.CharField()\n    mime = models.TextField()\n</code></pre>"},{"location":"adr/0000-faker-shortcuts/#related-issues","title":"Related Issues","text":"<p>When this ADR was created, we have some related issues for this decision:</p> <ul> <li>#21 [feature] create an shortcut module and define methods to basic faker methods</li> <li>#45 [feature] add support for parsing arguments to fake function</li> <li>#47 [documentation] explain better arguments of faker shortcuts</li> <li>#62 [feature] create shortcuts for file generation faker with real support for directly set model files</li> <li>#63 [feature] create json shortcuts</li> </ul>"},{"location":"philosophy/api-exception/","title":"API Exception's","text":"<p>This text introduces our philosophy about using API Exceptions to handle errors when writing django REST API's.</p>"},{"location":"philosophy/api-exception/#introduction","title":"Introduction","text":"<p>One of the possibles way to handle errors in django rest framework REST API's is writing manual responses on views, like that:</p> <pre><code>from rest_framework.views import APIView\nfrom rest_framework.response import Response\n\nclass SomeAPIView(APIView):\n    def post(self, request):\n        if not condition:\n            return Response({ 'detail': 'my any error', }, status=422)\n</code></pre> <p>or, without using early-return:</p> <pre><code>from rest_framework.views import APIView\nfrom rest_framework.response import Response\n\nclass SomeAPIView(APIView):\n    def post(self, request):\n        if condition:\n            # process here\n        else:\n            return Response({ 'detail': 'my any error', }, status=422)\n</code></pre> <p>This is not a good way of handle errors with django rest framework, specially for our package, because whe need to assert manually the response body and status. A other side of the problem is the cognitive load of multiple responses returning in one view function. The <code>APIException</code> concept solve the both problems.</p>"},{"location":"philosophy/api-exception/#example","title":"Example","text":"<p>The example bellow does the same logic, and return an 422 response with an detail if condition is false, like the above methods:</p> <pre><code>from rest_framework.exceptions import APIException\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\n\nclass CustomAPIException(APIException):\n    default_detail = 'my any error'\n    status_code = status.HTTP_422_UNPROCESSABLE_ENTITY\n\n\nclass SomeAPIView(APIView):\n    def post(self, request):\n        if not condition:\n            raise CustomAPIException()\n        # process request\n</code></pre>"},{"location":"philosophy/api-exception/#one-customizable-apiexception-vs-multiple-apiexception","title":"One customizable APIException vs Multiple APIException","text":"<p>One example of using customizable <code>APIException</code> is present on the <code>rest_framework_simplejwt</code> package:</p> <pre><code># ...\nclass TokenObtainSerializer(serializers.Serializer):\n    # ...\n    default_error_messages = {\n        \"no_active_account\": _(\"No active account found with the given credentials\")\n    }\n\n    def validate(self, attrs: Dict[str, Any]) -&gt; Dict[Any, Any]:\n        # ...\n        if not api_settings.USER_AUTHENTICATION_RULE(self.user):\n            raise exceptions.AuthenticationFailed(\n                self.error_messages[\"no_active_account\"],\n                \"no_active_account\",\n            )\n        # ...\n</code></pre> <p>For the purpose of this testing utilities package, using this way is a little bad for some reasons: this moves the detail and codes to the <code>APIView</code> or <code>Serializer</code> and, then, make the code a little more verbose than writing one APIException for each error and add more cognitive load on this code.</p> <p>For this testing package, this is a little bad because we need to redeclare this exceptions inside our tests, like this:</p> <pre><code>from django.utils.translation import gettext_lazy as _\nfrom rest_framework_simplejwt.serializers import TokenObtainSerializer\nfrom rest_framework_simplejwt.exceptions import AuthenticationFailed\nfrom rest_framework.exceptions import AuthenticationFailed as BaseAuthenticationFailed\n\nNO_ACTIVE_ACCOUNT = BaseAuthenticationFailed(\n    TokenObtainSerializer.default_error_messages[\"no_active_account\"],\n    \"no_active_account\",\n)\n\nTWO_AUTORIZATION_PARTS = AuthenticationFailed(\n    _(\"Authorization header must contain two space-delimited values\"),\n    code=\"bad_authorization_header\",\n)\n\n# ...\n</code></pre>"},{"location":"philosophy/authentication-behaviour/","title":"Authentication Behaviour","text":"<p>This text introduces our philosophy about authentication behaviour testing inside django REST API's.</p>"},{"location":"philosophy/authentication-behaviour/#introduction","title":"Introduction","text":"<p>The <code>APIClient</code> present at the <code>APITestCase</code> of the django and django-rest-framework provides two methods to work with authentication: <code>login()</code> and <code>force_login()</code> with two different behaviours. The first method uses the configured django authentication back-end's (equivalent of adapter design pattern, for non-django developers).</p> <p>As, we comented above, this methods uses the default django session authentication, because those methods are writen by default client and not by django-rest-framework or by djangorestframework-simplejwt, for jwt authentication-based API's.</p> <p>For example, this methods are good mehtods for testing the django-admin Ajax API Views, like the <code>AutocompleteJsonView</code> (ref) but are not effective for testing API's with JWT, Basic or Token model authentication-based API's.</p>"},{"location":"philosophy/authentication-behaviour/#our-philosophy","title":"Our Philosophy","text":"<p>Our philosophy about testing with JWT Authentication, or other Authorization header based method, is test all the behaviour of authentication inside the aplication with real use-cases. To made this work a little bit easy, we decided to introduce authentication helpers for the <code>APITestCase</code>.</p> <p>The helper is configurable and the agnostic methods and assertions are defined inside an mixin.</p>"},{"location":"philosophy/authentication-behaviour/#techinical-part","title":"Techinical Part","text":"<p>TODO: write technical part for this text.</p>"}]}